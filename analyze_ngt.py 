# align_with_teaser.py
import open3d as o3d
import numpy as np
import teaserpp_python
import json
import os
import sys
from argparse import ArgumentParser
import time

def solve_with_teaser(pred_pcd, gt_pcd, voxel_size):
    """
    使用 TEASER++ 算法计算从预测点云到真值点云的对齐变换。
    """
    print("─"*80)
    print("🚀 开始使用 TEASER++ 进行鲁棒对齐...")

    # 1. 预处理和特征提取 (与之前类似)
    print(f"  1. 正在进行体素下采样 (voxel_size = {voxel_size})...")
    pred_down = pred_pcd.voxel_down_sample(voxel_size)
    gt_down = gt_pcd.voxel_down_sample(voxel_size)

    print("  2. 正在计算法线和FPFH特征...")
    radius_normal = voxel_size * 2
    pred_down.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30))
    gt_down.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30))

    radius_feature = voxel_size * 5
    pred_fpfh = o3d.pipelines.registration.compute_fpfh_feature(pred_down, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100))
    gt_fpfh = o3d.pipelines.registration.compute_fpfh_feature(gt_down, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100))
    
    # 2. 建立初始匹配对 (不进行筛选，全部保留)
    print("  3. 正在建立初始特征匹配对...")
    # 使用 KDTree 寻找所有潜在的匹配
    gt_fpfh_tree = o3d.geometry.KDTreeFlann(gt_fpfh)
    corres = []
    for i in range(len(pred_down.points)):
        [k, idx, _] = gt_fpfh_tree.search_knn_vector_xd(pred_fpfh.data[:, i], 1)
        if k > 0:
            corres.append([i, idx[0]])

    print(f"     -> 找到了 {len(corres)} 个初始匹配对 (包含大量错误)")

    # 3. 准备 TEASER++ 需要的数据
    pred_pts = np.asarray(pred_down.points)[np.array(corres)[:, 0]]
    gt_pts = np.asarray(gt_down.points)[np.array(corres)[:, 1]]
    
    # TEASER++ 要求数据是 float64
    pred_pts = pred_pts.astype(np.float64).T
    gt_pts = gt_pts.astype(np.float64).T

    # 4. 配置并运行 TEASER++ 求解器
    print("  4. 正在配置并运行 TEASER++ 求解器...")
    # 求解器参数
    noise_bound = voxel_size # 这是一个关键参数，表示你认为匹配点之间的最大误差
    solver_params = teaserpp_python.RobustRegistrationSolver.Params()
    solver_params.cbar2 = 1.0
    solver_params.noise_bound = noise_bound
    solver_params.estimate_scaling = False # 我们已经确认没有尺度问题
    solver_params.rotation_estimation_algorithm = teaserpp_python.RobustRegistrationSolver.ROTATION_ESTIMATION_ALGORITHM.GNC_TLS
    solver_params.rotation_gnc_factor = 1.4
    solver_params.rotation_max_iterations = 100
    solver_params.rotation_cost_threshold = 1e-12

    solver = teaserpp_python.RobustRegistrationSolver(solver_params)
    start_time = time.time()
    solver.solve(pred_pts, gt_pts)
    end_time = time.time()
    
    solution = solver.getSolution()

    if solution.valid:
        print(f"     -> TEASER++ 求解成功! (耗时: {end_time - start_time:.2f}s)")
        # 5. 构建 4x4 变换矩阵
        final_transform = np.identity(4)
        final_transform[:3, :3] = solution.rotation
        final_transform[:3, 3] = solution.translation
        print("✅ 对齐矩阵计算成功!")
        print("─"*80)
        return final_transform
    else:
        print("❌ TEASER++ 未能找到有效的解。")
        print("─"*80)
        return None


def main():
    parser = ArgumentParser(description="使用 TEASER++ 鲁棒算法自动计算3DGS点云到真值点云的对齐矩阵。")
    parser.add_argument("--pred_pcd_path", type=str, required=True, help="预测点云的路径。")
    parser.add_argument("--gt_pcd_path", type=str, required=True, help="高质量的、降采样后的真值点云的路径。")
    parser.add_argument("--output_json", type=str, required=True, help="输出的对齐JSON文件的路径。")
    parser.add_argument("--scene_name", type=str, required=True, help="当前场景的名称，将作为JSON文件中的key。")
    parser.add_argument("--voxel_size", type=float, default=0.1, help="用于下采样和特征计算的体素大小(米)。这是最重要的参数，需要根据场景尺度进行调整。")
    
    args = parser.parse_args()

    # 1. 加载点云
    try:
        pred_pcd = o3d.io.read_point_cloud(args.pred_pcd_path)
        gt_pcd = o3d.io.read_point_cloud(args.gt_pcd_path)
        if not pred_pcd.has_points() or not gt_pcd.has_points():
            print("❌ 错误: 一个或两个点云文件为空或无法加载。")
            sys.exit(1)
    except Exception as e:
        print(f"❌ 错误: 加载点云失败: {e}")
        sys.exit(1)

    # 2. 计算变换矩阵
    transform_matrix = solve_with_teaser(pred_pcd, gt_pcd, args.voxel_size)

    if transform_matrix is None:
        print("\n❌ 计算失败，未生成JSON文件。")
        sys.exit(1)

    # 3. 加载或创建现有的JSON文件
    if os.path.exists(args.output_json):
        print(f"\n🔄 发现现有JSON文件 '{args.output_json}', 将更新或添加场景 '{args.scene_name}'...")
        with open(args.output_json, 'r') as f:
            data = json.load(f)
    else:
        print(f"\n✨ 未发现现有JSON文件，将创建新文件 '{args.output_json}'...")
        data = {}

    # 4. 更新数据并保存
    data[args.scene_name] = transform_matrix.tolist()

    with open(args.output_json, 'w') as f:
        json.dump(data, f, indent=4)
    
    print(f"✅ 成功将场景 '{args.scene_name}' 的对齐矩阵保存到 '{args.output_json}'!")
    print("\n现在您可以在主评估脚本中使用这个JSON文件了。")

if __name__ == "__main__":
    main()