# align_with_teaser.py
import open3d as o3d
import numpy as np
import teaserpp_python
import json
import os
import sys
from argparse import ArgumentParser
import time

def solve_with_teaser(pred_pcd, gt_pcd, voxel_size):
    """
    ä½¿ç”¨ TEASER++ ç®—æ³•è®¡ç®—ä»é¢„æµ‹ç‚¹äº‘åˆ°çœŸå€¼ç‚¹äº‘çš„å¯¹é½å˜æ¢ã€‚
    """
    print("â”€"*80)
    print("ğŸš€ å¼€å§‹ä½¿ç”¨ TEASER++ è¿›è¡Œé²æ£’å¯¹é½...")

    # 1. é¢„å¤„ç†å’Œç‰¹å¾æå– (ä¸ä¹‹å‰ç±»ä¼¼)
    print(f"  1. æ­£åœ¨è¿›è¡Œä½“ç´ ä¸‹é‡‡æ · (voxel_size = {voxel_size})...")
    pred_down = pred_pcd.voxel_down_sample(voxel_size)
    gt_down = gt_pcd.voxel_down_sample(voxel_size)

    print("  2. æ­£åœ¨è®¡ç®—æ³•çº¿å’ŒFPFHç‰¹å¾...")
    radius_normal = voxel_size * 2
    pred_down.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30))
    gt_down.estimate_normals(o3d.geometry.KDTreeSearchParamHybrid(radius=radius_normal, max_nn=30))

    radius_feature = voxel_size * 5
    pred_fpfh = o3d.pipelines.registration.compute_fpfh_feature(pred_down, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100))
    gt_fpfh = o3d.pipelines.registration.compute_fpfh_feature(gt_down, o3d.geometry.KDTreeSearchParamHybrid(radius=radius_feature, max_nn=100))
    
    # 2. å»ºç«‹åˆå§‹åŒ¹é…å¯¹ (ä¸è¿›è¡Œç­›é€‰ï¼Œå…¨éƒ¨ä¿ç•™)
    print("  3. æ­£åœ¨å»ºç«‹åˆå§‹ç‰¹å¾åŒ¹é…å¯¹...")
    # ä½¿ç”¨ KDTree å¯»æ‰¾æ‰€æœ‰æ½œåœ¨çš„åŒ¹é…
    gt_fpfh_tree = o3d.geometry.KDTreeFlann(gt_fpfh)
    corres = []
    for i in range(len(pred_down.points)):
        [k, idx, _] = gt_fpfh_tree.search_knn_vector_xd(pred_fpfh.data[:, i], 1)
        if k > 0:
            corres.append([i, idx[0]])

    print(f"     -> æ‰¾åˆ°äº† {len(corres)} ä¸ªåˆå§‹åŒ¹é…å¯¹ (åŒ…å«å¤§é‡é”™è¯¯)")

    # 3. å‡†å¤‡ TEASER++ éœ€è¦çš„æ•°æ®
    pred_pts = np.asarray(pred_down.points)[np.array(corres)[:, 0]]
    gt_pts = np.asarray(gt_down.points)[np.array(corres)[:, 1]]
    
    # TEASER++ è¦æ±‚æ•°æ®æ˜¯ float64
    pred_pts = pred_pts.astype(np.float64).T
    gt_pts = gt_pts.astype(np.float64).T

    # 4. é…ç½®å¹¶è¿è¡Œ TEASER++ æ±‚è§£å™¨
    print("  4. æ­£åœ¨é…ç½®å¹¶è¿è¡Œ TEASER++ æ±‚è§£å™¨...")
    # æ±‚è§£å™¨å‚æ•°
    noise_bound = voxel_size # è¿™æ˜¯ä¸€ä¸ªå…³é”®å‚æ•°ï¼Œè¡¨ç¤ºä½ è®¤ä¸ºåŒ¹é…ç‚¹ä¹‹é—´çš„æœ€å¤§è¯¯å·®
    solver_params = teaserpp_python.RobustRegistrationSolver.Params()
    solver_params.cbar2 = 1.0
    solver_params.noise_bound = noise_bound
    solver_params.estimate_scaling = False # æˆ‘ä»¬å·²ç»ç¡®è®¤æ²¡æœ‰å°ºåº¦é—®é¢˜
    solver_params.rotation_estimation_algorithm = teaserpp_python.RobustRegistrationSolver.ROTATION_ESTIMATION_ALGORITHM.GNC_TLS
    solver_params.rotation_gnc_factor = 1.4
    solver_params.rotation_max_iterations = 100
    solver_params.rotation_cost_threshold = 1e-12

    solver = teaserpp_python.RobustRegistrationSolver(solver_params)
    start_time = time.time()
    solver.solve(pred_pts, gt_pts)
    end_time = time.time()
    
    solution = solver.getSolution()

    if solution.valid:
        print(f"     -> TEASER++ æ±‚è§£æˆåŠŸ! (è€—æ—¶: {end_time - start_time:.2f}s)")
        # 5. æ„å»º 4x4 å˜æ¢çŸ©é˜µ
        final_transform = np.identity(4)
        final_transform[:3, :3] = solution.rotation
        final_transform[:3, 3] = solution.translation
        print("âœ… å¯¹é½çŸ©é˜µè®¡ç®—æˆåŠŸ!")
        print("â”€"*80)
        return final_transform
    else:
        print("âŒ TEASER++ æœªèƒ½æ‰¾åˆ°æœ‰æ•ˆçš„è§£ã€‚")
        print("â”€"*80)
        return None


def main():
    parser = ArgumentParser(description="ä½¿ç”¨ TEASER++ é²æ£’ç®—æ³•è‡ªåŠ¨è®¡ç®—3DGSç‚¹äº‘åˆ°çœŸå€¼ç‚¹äº‘çš„å¯¹é½çŸ©é˜µã€‚")
    parser.add_argument("--pred_pcd_path", type=str, required=True, help="é¢„æµ‹ç‚¹äº‘çš„è·¯å¾„ã€‚")
    parser.add_argument("--gt_pcd_path", type=str, required=True, help="é«˜è´¨é‡çš„ã€é™é‡‡æ ·åçš„çœŸå€¼ç‚¹äº‘çš„è·¯å¾„ã€‚")
    parser.add_argument("--output_json", type=str, required=True, help="è¾“å‡ºçš„å¯¹é½JSONæ–‡ä»¶çš„è·¯å¾„ã€‚")
    parser.add_argument("--scene_name", type=str, required=True, help="å½“å‰åœºæ™¯çš„åç§°ï¼Œå°†ä½œä¸ºJSONæ–‡ä»¶ä¸­çš„keyã€‚")
    parser.add_argument("--voxel_size", type=float, default=0.1, help="ç”¨äºä¸‹é‡‡æ ·å’Œç‰¹å¾è®¡ç®—çš„ä½“ç´ å¤§å°(ç±³)ã€‚è¿™æ˜¯æœ€é‡è¦çš„å‚æ•°ï¼Œéœ€è¦æ ¹æ®åœºæ™¯å°ºåº¦è¿›è¡Œè°ƒæ•´ã€‚")
    
    args = parser.parse_args()

    # 1. åŠ è½½ç‚¹äº‘
    try:
        pred_pcd = o3d.io.read_point_cloud(args.pred_pcd_path)
        gt_pcd = o3d.io.read_point_cloud(args.gt_pcd_path)
        if not pred_pcd.has_points() or not gt_pcd.has_points():
            print("âŒ é”™è¯¯: ä¸€ä¸ªæˆ–ä¸¤ä¸ªç‚¹äº‘æ–‡ä»¶ä¸ºç©ºæˆ–æ— æ³•åŠ è½½ã€‚")
            sys.exit(1)
    except Exception as e:
        print(f"âŒ é”™è¯¯: åŠ è½½ç‚¹äº‘å¤±è´¥: {e}")
        sys.exit(1)

    # 2. è®¡ç®—å˜æ¢çŸ©é˜µ
    transform_matrix = solve_with_teaser(pred_pcd, gt_pcd, args.voxel_size)

    if transform_matrix is None:
        print("\nâŒ è®¡ç®—å¤±è´¥ï¼Œæœªç”ŸæˆJSONæ–‡ä»¶ã€‚")
        sys.exit(1)

    # 3. åŠ è½½æˆ–åˆ›å»ºç°æœ‰çš„JSONæ–‡ä»¶
    if os.path.exists(args.output_json):
        print(f"\nğŸ”„ å‘ç°ç°æœ‰JSONæ–‡ä»¶ '{args.output_json}', å°†æ›´æ–°æˆ–æ·»åŠ åœºæ™¯ '{args.scene_name}'...")
        with open(args.output_json, 'r') as f:
            data = json.load(f)
    else:
        print(f"\nâœ¨ æœªå‘ç°ç°æœ‰JSONæ–‡ä»¶ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶ '{args.output_json}'...")
        data = {}

    # 4. æ›´æ–°æ•°æ®å¹¶ä¿å­˜
    data[args.scene_name] = transform_matrix.tolist()

    with open(args.output_json, 'w') as f:
        json.dump(data, f, indent=4)
    
    print(f"âœ… æˆåŠŸå°†åœºæ™¯ '{args.scene_name}' çš„å¯¹é½çŸ©é˜µä¿å­˜åˆ° '{args.output_json}'!")
    print("\nç°åœ¨æ‚¨å¯ä»¥åœ¨ä¸»è¯„ä¼°è„šæœ¬ä¸­ä½¿ç”¨è¿™ä¸ªJSONæ–‡ä»¶äº†ã€‚")

if __name__ == "__main__":
    main()